목적 : 트위터, 인스타그램 등 제한된 글자를 게시 할 때 긴 URL이 공유되면 추가로 활용 될 글자 수가 적어지기에 이를 최소화하고자 URL 단축기를 생성한다.

**URL 단축기 구현 요구사항**

- URL 단축 : 주어진 긴 URL을 줄이는 기능
- URL 리디렉션 : 축약된 URL로 HTTP 요청이 오면 원래 URL로 안내
- 높은 가용성과 규모 확장성, 장애감내

**트래픽 조건**

- 쓰기 연산 : 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산 : 1억 / 24(시간) / 3600(분*초) = 1160 QPS
- 읽기 연산 : 읽기 9:1 비율이라 치면 읽기는 1160 * 9 = 10440 QPS
- URL 단축 서비스를 10년 운영한다고 가정했을 때 1억 * 365 * 10 = 3650억
- 축약 전 URL의 평균 길이 : 100바이트

⇒ 10년동안  필요한 저장 공간 : 100바이트 * 3650억 = 36.5TB

**기본적인 단축 통신 방식**

`POST /api/v1/data/shorten?longUrl=longURLstring`

- post에 대한 인자가 파라미터로 될지 바디로 될지 맞추기
- 반환 : 단축 URL

**URL 리디렉션용 엔드 포인트**

단축 URL으로 HTTP 요청이 들어왔을 때 원래 URL로 보내주기 위한 엔드포인트

`GET /api/v1/shortUrl`

**단축 URL이 들어왔을 때 처리 방법**

- 301 Permanently Moved 반환
    - HTTP 요청의 처리 책임이 Location 에 있는 URL로 이전되었다는 뜻(최초 응답을 받은 이후 캐시 처리)
- 302 Found 반환
    - 주어진 URL로 요청이 일시적으로 Location에 있는 URL에 의해 처리되어야 한다는 응답 (매 요청마다 확인 후 이동)

301은 캐싱하기에 트래픽 절감에 효과적일 것이며, 302는 매 요청마다 서버를 반드시 들르기에 트래픽 분석이 가능하다.
따라서, 상황에 맞게 요청응답 방식을 활용하면 될 것이다.

## URL 단축

### 해시 형태 URL

URL과 단축해시 URL은 1:1 매핑되어야 한다.(고유 단축 URL)
계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.(긴 URL 원본이 있어야 하기 때문)

URL 단축 시 해시된 URL을 빠르게 반환하기 위해서는 메모리에 전부 저장하면 좋을테지만, 위에서 대략적인 데이터를 확인했을 때 용량이 상당했기에, 메모리는 사용 불가능하며, 휘발되면 안되기에 RDBMS에 저장하는 것이 보편적이다.

### URL 생성

최초 요구사항인 3650억개의 URL을 생성하기 위해서 0~9(10), a~z(26), A~Z(26) 의 경우의 수를 모두 합친 길이를 표현한다면, 62^7 : 약 3.5조로 요구사항을 만족할 수 있다.

**해시 후 충돌 해소**

다양한 해시 방법을 통해 결과를 만들어냈을 때 원하는 잘 알려진 해시 함수를 이용해 해시 결과를 받아서, 문자열 등을 뒤에 추가해서 유일성을 만족시킨다.

**base-62 변환**

62진수 변환을 통해 모든 값을 줄인다.
이는 가장 보편적으로 사용하는 방식이다.

* base-64 기법도 존재하지만, url에는 맞지 않은 변환방식

**해시 후 충돌 해소 전략 VS base-62 변환**

- 해시 후 충돌 해소 전략
    - 단축 URL의 길이가 고정됨
    - 유일성이 보장되는 ID 생성기가 필요치 않음
    - 충돌이 가능해서 해소 전략 필요
    - ID로부터 단축 URL을 계산하는 방식이 아니라서 다음에 쓸 수 있는 URL을 알아내는 것이 불가능
- base-62 변환
    - 단축 URL의 길이가 가변적, ID값이 커지면 같이 길어짐
    - 유일성 보장 ID 생성기가 필요
    - ID의 유일성이 보장된 후에 적용 가능한 전략이기에 충돌은 불가능
    - ID가 1씩 증가하는 값이라고 가정하면, 다음 단축 URL이 무엇인지 알 수 있기에 보안상 문제 가능성 존재

### URL 리디렉션 상세 설계 흐름

1. 사용자가 단축 URL 클릭
2. 로드밸런서가 해당 클릭으로 발생한 요청을 웹 서버에 전달
3. 단축 URL이 이미 캐시에 있는 경우 원래 URL을 바로 꺼내서 클라이언트에게 전달
4. 캐시에 해당 단축 URL이 없는 경우에는 데이터베이스에서 꺼낸다. 데이터베이스에 미존재 시 잘못된 단축 URL
5. 데이터베이스에서 꺼낸 URL을 캐시에 넣은 후 사용자에게 반환
