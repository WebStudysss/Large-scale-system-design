# 분산 시스템을 위한 유일ID 생성기 설계

분산 시스템에선 여러 분산 DB를 사용해야 하기에 auto_increment 속성을 활용하기 힘들다

유일성이 보장되는 ID 발급 방식을 배워보자

요구사항

- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다.

분산 시스템에서 유일성을 보장하는 ID 발급방식

- 다중 마스터 복제(multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(ticket server)
- 트위터 스노플레이크(twitter snowflake) 접근법
- 시퀀스 블록 할당

### 다중 마스터 복제

각 분산 마스터 DB에 auto_increment를 적용하는데  offset과 increment 간격을 서버 수로 조정해 auto_increment 키를 유일성을 보장할 수 있도록 구현 가능

장점 : 단순
단점 : db서버 노드를 늘렸을 때 기본키 분배 방식을 재배치 해야 하는데, 중단 없는 서비스에서는 활용하기 까다로움

### UUID

UUID는 각 서버별로 클라이언트에서 직접 생성하기도 용이하고, 중복 가능성 또한 매우 낮기에 주로 활용된다. 또한 식별 크기가 128비트짜리 수 이기에 위 요구사항과는 맞지 않음

* 요구 사항 중 시간순으로 정렬할 수 없다는 것은 UUIDv4로 생성했을 때의 기준이므로, 아래의 표를 같이 참고해서 시간순 정렬은 가능해질 가능성이 높은 것을 염두해 두면 좋아 보인다.

```java
UUID

UUID v1~v4는 RFC 4122로 정의된 규격으로,
현재 보편적으로 사용되고 있는 버전은 UUID의 가장 마지막 버전인 UUIDv4 이다.
또한 6, 7은 시간순 정렬이 가능하도록 구현된 RFC 규격 외의 버전이지만 시간 순으로 정렬이 가능한 장점이 있다.

RFC9562로 인해 최종 UUID v7까지 표준에 포함되었다. v6, v7 모두 시간순 정렬이 가능하나,
v6는 MAC 주소가 담기는 부분이 있어, v1과의 호환을 위한 UUID라고 한다.
v7이 보안상 이점이 더 많기에 v7을 사용하는 것이 좋아보인다.

RFC9562 : https://www.rfc-editor.org/rfc/rfc9562.html

UUIDv1: 시간 포함, 하지만 정렬 비효율
UUIDv4: 완전 랜덤, 충돌 확률은 낮지만 시간 의미 없음
UUIDv6: 시간 포함 + 정렬성 보장 (RDB 인덱스 친화적)
UUIDv7: 최근 표준화 방향, v6와 유사하지만 Unix time 밀리초 기반 + 랜덤비트 추가 → 더 단순·현대적
```

### 티켓 서버

auto_increment를 발급해주는 전용 서버를 하나 두는 것을 말한다.
ID를 발급 받기 위해 티켓서버로 요청해 ID를 발급받은 후, 해당 ID로 특정 테이블 row를 생성한다.
이는 SPOF문제 해결이 까다롭다

### 트위터 스노플레이크

사인 1비트, 타임스탬프 41비트, 데이터센터 ID 5비트, 서버ID 5비트를 각각 할당해서, 고유한 번호를 만드는 방식이다.
이 방식은 타임스탬프의 41비트로 표현할 수 있는 범위(약 69년)까지가 유효기간이다.

### + 시퀀스 블록 할당

시퀀스 블록은 특정 범위의 ID 범위를 미리 준비해 둔 후, 요청이 온 순서에 따라 해당 ID 블록을 할당해 주는 형태이다.

```java
장점
DB 부하 감소: 매번 DB에 가지 않고, 블록 단위로만 접근
충돌 없음: 블록을 서버별로 나누니까 중복 ID 방지
고속 ID 발급 가능: 로컬에서만 카운터 증가

단점
ID 불연속성: 서버가 블록을 다 쓰기 전에 죽으면, 그 블록의 나머지 ID는 버려짐 따라서 ID는 “연속적”이지 않고 “고유성만 보장”
재할당 지연: 블록 크기를 너무 작게 잡으면 자주 DB에 가야 해서 효율이 떨어짐
운영 튜닝 필요: 블록 크기를 얼마나 크게 할지 결정해야 함 (너무 크면 낭비, 너무 작으면 DB 부하)
```
