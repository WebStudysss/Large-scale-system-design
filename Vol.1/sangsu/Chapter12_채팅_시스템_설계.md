## 요구사항 도출

- 1:1 채팅과 그룹 채팅
- 모바일, 웹
- DAU 5천만
- 그룹 채팅 최대 100명 참가
- 주요 기능 : 1:1채팅, 그룹 채팅, 사용자 접속상태 표시, 채팅은 텍스트만
- 메시지 길이 10만자 이하
- 종단 단 암호화 지원
- 채팅 이력 영구 보관

## 실제 설계할 설계안

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅
- 사용자의 접속상태 표시
- 다양한 단말 지원 및 하나의 계정으로 여러 단말 동시 접속 지원
- 푸시 알림

## 프로토콜

- 폴링
    - 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는 방법
- 롱 폴링
    - 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는데, 새 메시지가 있다고 답변을 받거나 타임아웃 될 때까지 서버에서 반환해주지 않는다.
- 웹소켓
    - 서버가 클라이언트에게 비동기 메시지를 보낼 때 널리 사용하는 기술
    - 클라이언트가 HTTP 핸드셰이크 연결을 요청 → 서버 측 ACK 반환 ⇒ 메시지 양방향 전송

## 저장소 관리

저장소는 RDBMS를 채택할 것인지 NoSQL을 채택할 것인지를 확인해야 한다.

NoSQL 키 값 저장소를 채택하게된다. 관계형 데이터베이스는 롱테일 부분을 빠르게 처리하지 못하기에 고려 대상에서 제외되었다.

1:1 테이블

- Table : message, PK : message_id

Group 테이블

- Table : group message, PK : channel_id, message_id

메시지 id는 UUIDv7 이거나 snowflake 등의 방법이 있을 것 같다

추가로 데이터 티어링을 생각해서 데이터 보관 전략을 생각해두면 더 유용할 것 같다

**데이터 티어링**

hot 자주 사용되는거 - Redis Memory 계열로 저장 (`하루!!!!!!!!!`)

warm 적당히 사용되는거 - NoSQL MongoDB (1주일)

cold 오랫동안 보관하고 거의 사용 안하는거 - RDBMS (영구)

### 접속 상태 정보 저장

웹 소켓 통신을 통해 서버에 저장할 때마다

박동 이벤트를 추가로 넣어서 체크한다.

이 책의 예시로는 박동 이벤트 기준으로 30초가 지날 시 오프라인 상태로 간주한다.

1:1의 경우에는 구현이 쉽겠지만, 그룹 채팅에서는 각 그룹별로 박동 이벤트를 확인하는 큐를 사용자별로 생성해야 하기에, 효율이 좋지 않다.

이 때는 상태 정보 갱신하는 방법으로, 특정 채팅방에 들어갔을 때만 상태 정보를 업데이트 시키는 방법이 있다.

### 그 외의 고려사항

**종단 간 암호화** : 발신인과 수신자를 제외하고는 메시지 내용을 볼 수 없도록 암호화

**캐시** : 이미 읽은 메시지를 클라이언트에서 캐시해두면 서버와 주고받는 데이터 양을 줄일 수 있다.

**로딩 속도 개선** : 슬랙은 사용자의 데이터, 채널을 지역적으로 분산하여, 앱 로딩 속도를 개선

**오류 처리** : 채팅 서버 오류, 매시지 재전송 등의 방법 고려
