### 요구사항

- 검색어의 첫 부분
- 5개의 자동완성 검색어
- 영어 기준 질의
- DAU 천만

### 개략적 규모 추정

- 질의할 때마다 평균 20 바이트 데이터 입력
⇒ ASCII 기준으로 1문자당 1바이트
⇒ 4개 문자는 20바이트

검색창에 글자를 입력할 때마다 백엔드로 자동 요청하는 방식으로 구현 될 예정

**작은 규모의 서비스에서 검색어 자동완성**

RDBMS의 내림차순 인덱싱을 사용해서 가져오면 될 것이다.

**데이터 양이 많아졌을 때는?**

- 트라이(trie) 자료구조
- 데이터 수집 서비스
- 질의 서비스
- 규모 확장이 가능한 저장소
- 트라이 연산

### 트라이 자료구조

RDBMS로 다섯 개 질의문 고르는 방식은 효율적이지 않기에, 트라이(trie, 접두어 트리prefix tree)로 해결

트라이 자료구조는 문자열을 간략하게 저장할 수 있는 자료구조이다.

**트라이 자료구조는 어떻게 동작하는가?**

트리 형태로 구현되며, 루트 노드를 빈 문자열로 두고 나머지 자식 노드들은 글자 하나씩 저장하며, 확장해 나가는 형태. 모든 알파벳 수인 26개의 자식 노드를 가질 수 있다.

위의 트라이 자료구조를 활용해 각 최종 자식 노드에 빈도 수를 같이 저장한다고 가정해보자.

tre를 검색했을 때 두 개의 검색어가 우선순위에 따라 보여질 수 있도록 처리되는 형태

tre → tree : 10, treat : 30

ex) t → r → e → tre 검색어인 tree, treat 두 개가 보일 수 있다.

k개의 결과를 얻기 위해 전체 트라이를 다 검색해야 하는 일이 생길 수 있는데, 이를 방지하기 위해서는

1. 접두어의 최대 길이 제한
2. 각 노드에 인기 검색어 캐시

### 데이터 수집 서비스

매일 수천만 건의 질의가 입력될 텐데 그때마다 트라이를 갱신하면 

규모 확장이 쉬운 데이터 수집 서비스를 위한 작업
⇒ 실시간으로 검색어가 추가될 때마다 트라이에 넣는 것은 좋지 않은 방식

**데이터 분석 서비스 로그**

검색된 데이터를 갖고있는 로그에는 검색어와 검색 시간이 있기에, 로그 분석을 통해 트라이를 만드는 것이 가장 현실적

⇒ 검색어 수집 - 일주일에 한번

- 작업 서버
- 트라이 캐시
- 트라이 데이터베이스
    - 문서 저장소(document store)
    - 키-값 저장소

**질의 서비스**

클라이언트 → 로드밸런서 → API 서버 → 트라이 캐시 → 트라이 데이터 베이스

트래픽을 최소화 하기 위해서는 캐시가 적극 활용되어야 하며, 인기 검색어는 자주 바뀌지 않기 때문에 브라우저 캐싱을 통해 사용자의 중복 요청 또한 피하도록 돕는다

검색어 삭제 - 필터링 계층을 두어 검색어에 대해 처리가 되어야한다.

**저장소 규모 확장**

첫글자 기준 샤딩 방법으로 분리 가능

**추가 고려 사항**

- 다국어 지원
- 국가별 인기 검색어 순위를 다르게

### 트라이 알고리즘 문제

- 5052번 전화번호 목록(골드 4) https://www.acmicpc.net/problem/5052
- 9202번 Boggle (플래 5) https://www.acmicpc.net/problem/9202
- 5670번 휴대폰 자판 (플래 4) https://www.acmicpc.net/problem/5670
