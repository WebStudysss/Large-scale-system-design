# 처리율 제한 장치의 설계(rate limiter)

네트워크/분산 시스템에서 **처리율 제한 장치(rate limiter)** 는 클라이언트 또는 서비스가 보내는 요청의 **처리율(rate)** 을 제어하는 컴포넌트다.

---

## 1) 왜 필요한가 (효과)

- **자원 고갈(Denial of Service) 방지**: DoS/봇 트래픽으로부터 백엔드 보호
- **비용 절감**: 불필요한 추가 인스턴스 확장을 줄임
- **과부하 방지**: 사용자 오류/봇/이상 트래픽을 차단해 안정적 처리 유지

---

## 2) 배치 위치 (어디에 둘 것인가)

### 클라이언트 측
- **단점**: 클라이언트는 위변조/우회가 쉬움, 모든 클라이언트를 통제하기 어려움  
→ **보안·신뢰성 측면에서 비권장**

### 서버 측
- **권장**: API 앞단에서 중앙집중적으로 제어
- **구성 예시**
  - (그림 4-1/4-2) **애플리케이션 내부 미들웨어**로 구현
  - (그림 4-3) **API 게이트웨이**에 구현 (일반적)
    - 게이트웨이에서 **Rate Limiting, SSL Termination, 인증, IP 허용목록** 등을 통합 제공
    - 완전 관리형으로 운영 편의성이 높음

---

## 3) 대표 알고리즘과 특성

> 각 알고리즘은 **버스트 처리 능력**, **메모리 사용량**, **정밀도** 가 다름. 환경에 맞게 단독 또는 조합해서 사용.

### 3.1 토큰 버킷 (Token Bucket)
- **개념**: 용량이 `B` 인 버킷에 초당 `R`개의 토큰을 보충(refill). 요청 1건 당 토큰 1개 소비. 토큰이 없으면 거부.
- **파라미터**
  - `버킷 크기(B)` — 허용 가능한 **버스트** 크기
  - `토큰 공급률(R)` — 단위 시간당 허용 처리율
- **장점**: 구현 간단, 메모리 효율적, **버스트 허용**에 강함
- **단점**: `B`와 `R` 튜닝이 까다로울 수 있음
- **적용**: **API 엔드포인트/사용자/IP 별**로 버킷을 분리하여 적용 가능

### 3.2 누출 버킷 (Leaky Bucket)
- **개념**: 고정 속도로 “새는” 버킷. 보통 **FIFO 큐**로 구현. 큐가 가득 차면 신규 요청 드롭.
- **파라미터**: `버킷 크기(큐 길이)`, `처리율(outflow rate)`
- **장점**: 메모리 사용 예측 가능, **출력(처리율) 안정적**
- **단점**: 단시간 급증 시 오래된 요청 대기/드롭 가능, 튜닝 난이도 존재
- **적용**: **고정 속도 처리**가 중요한 백엔드

### 3.3 고정 윈도 카운터 (Fixed Window Counter)
- **개념**: 시간을 고정 간격 윈도로 나누고, 윈도별 카운터가 임계치 도달 시 남은 요청 드롭
- **장점**: 단순, 메모리 효율 좋음
- **단점**: **윈도 경계 문제**(경계 부근 트래픽 급증 시 한도 초과 허용 가능)

### 3.4 이동 윈도 로그 (Sliding Window Log)
- **개념**: 최근 윈도 구간의 **요청 타임스탬프**를 저장(예: Redis Sorted Set). 만료 제거 후 크기를 기준으로 허용/차단 결정
- **장점**: 어떤 순간의 윈도에서도 **정확한 한도 준수**
- **단점**: **메모리 사용 큼**(거부된 요청 로그도 저장)

### 3.5 이동 윈도 카운터 (Sliding Window Counter)
- **개념**: **고정 윈도**와 **이동 로그** 타협안.  
  현재 윈도 카운트 + 직전 윈도 카운트 × **겹치는 비율**로 현재 시점의 추정 카운트를 계산
- **예시**: 현재 1분 카운트=3, 직전 1분 카운트=5, 겹침 70% → `3 + 5 × 0.7 = 6.5` (반올림/내림 정책 적용)
- **장점**: **버스트 대응력** 좋고 **메모리 효율적**
- **단점**: 균등 분포 가정에 기반한 **근사치**(실무에선 오차 매우 낮음)

---

## 4) 한도 초과 처리와 클라이언트 통지

- **HTTP 상태코드**: `429 Too Many Requests`
- **응답 헤더(예시)**  
  - `X-RateLimit-Remaining`: 현재 윈도에서 남은 요청 수  
  - `X-RateLimit-Limit`: 윈도당 허용 요청 수  
  - `X-RateLimit-Retry-After`: 재시도까지 남은 초(또는 절대시각)

---

## 5) 상세 아키텍처 (서버 측 미들웨어 예)

1. **규칙 저장**: 처리율 제한 규칙은 디스크/설정 저장소에 보관하고 워커가 **캐시**(예: Redis/로컬 메모리)에 적재
2. **요청 유입**: 클라이언트 요청 → **Rate Limiting 미들웨어** 진입
3. **평가**: 미들웨어가 **규칙 + 카운터/타임스탬프**(보통 Redis)에 근거해 허용 여부 판단
4. **결정**
   - 허용: **API 서버**로 전달
   - 차단: **429** 반환 (필요 시 **메시지 큐**에 보관/지연 처리)

---

## 6) 분산 환경에서의 과제

### 6.1 경쟁 조건 (Race Condition)
- **문제**: 병렬 요청이 같은 카운터를 읽고 동시에 갱신 → 한도 초과 허용 가능
- **전통적 해결**: 분산 락(성능 저하 우려)
- **대안**
  - **Redis Lua 스크립트**: 읽기·검사·증가를 **원자적**으로 수행
  - **Redis Sorted Set**: 타임스탬프 기반 윈도 계산을 **단일 명령 묶음**으로 처리

### 6.2 동기화(Synchronization)
- **문제**: 무상태 웹 계층에서 요청이 **여러 Rate Limiter 인스턴스**로 분산되면, 각 인스턴스가 동일 클라이언트 상태를 모르기 쉬움
- **비권장**: **Sticky Session**(확장성/장애 대응에 불리)
- **권장**: **중앙 저장소(예: Redis)** 를 통한 상태 공유

---

## 7) 성능·지연과 다중 리전(데이터센터)

- **지연(latency) 최소화**: 사용자와 가까운 **엣지/리전**에 Rate Limiter 배치
- **데이터 동기화**: 글로벌 분산 시 **최종적 일관성(eventual consistency)** 전략 고려(약간의 허용 오차 vs. 지연/비용 절충)

---

## 8) 모니터링 포인트

- **알고리즘 효과성**: 거부율(429), 버스트 시 응답 지연, 허용/거부 정확도
- **규칙 적정성**: 한도 값이 과도/과소한지, 사용자·엔드포인트별 분포
- **자원 지표**: Redis/스토리지 QPS·메모리, 미들웨어 CPU·레이턴시
- **비즈니스 지표**: 정상 사용자 불편 최소화, 악성 트래픽 억제 정도

---

## 9) 선택 가이드 (요약)

- **버스트 허용 + 단순/효율** → **토큰 버킷**
- **고정 출력(안정 속도)** → **누출 버킷**
- **간단·메모리 절약** → **고정 윈도**
- **정확한 윈도 한도 준수** → **이동 윈도 로그**
- **정확도·메모리·성능의 균형** → **이동 윈도 카운터**(실무 기본값으로 적합)

---

## 10) 설계 체크리스트

- [ ] 한도 단위: **사용자/토큰/IP/엔드포인트/조합** 중 무엇인가?  
- [ ] 윈도 단위: **초/분/시간/하루** (비즈니스/보안 요구 반영)  
- [ ] 버스트 허용 여부: 허용 시 **버킷 크기(B)** 정의  
- [ ] 저장소: **Redis**(원자 연산/Lua/ZSET), 지역성·복제·HA  
- [ ] 분산 고려: 여러 인스턴스/리전 간 **상태 일관성** 전략  
- [ ] 실패 처리: 429 응답 포맷/헤더, **Retry-After** 정책  
- [ ] 우회 트래픽: 내부 서비스·백오피스·헬스체크 **화이트리스트**  
- [ ] 관측성: 대시보드(허용/거부/지연/에러), 알람 임계치

# 느낀점

- 단순히 "처리율 제한 = 요청 수 제한" 이 아니라, **알고리즘 선택에 따라 시스템 특성이 달라진다**는 점이 중요하다.  
  - 토큰 버킷은 **버스트 허용**에 강하고,  
  - 누출 버킷은 **안정적 출력 보장**에 적합하며,  
  - 이동 윈도 알고리즘은 **정확성과 효율성의 균형**을 제공한다.  
- 분산 환경에서 단일 서버 기준의 알고리즘만 생각하면 안 되고, **경쟁 조건(race condition)** 과 **상태 동기화(synchronization)** 문제까지 고려해야 한다는 점을 배웠다.  
- 단순히 락으로 동기화하는 것보다 **Redis Lua 스크립트나 ZSET** 같은 자료구조로 원자성을 확보하는 방식이 더 실무적이라는 사실이 흥미로웠다.  
- API Rate Limiter는 보안/안정성 목적뿐 아니라, **비용 절감과 서비스 품질 관리(QoS)** 를 위한 전략적 도구라는 점도 새롭게 알게 되었다.  
- 앞으로 실제 프로젝트에서 적용할 때는 **“누구를 기준으로 제한할 것인가(사용자, 토큰, IP, 엔드포인트)”** 와 **“비즈니스에 맞는 윈도 단위”** 를 먼저 정의하는 게 가장 중요하다고 느꼈다.